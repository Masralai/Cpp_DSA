# C++ Fundamentals Study Notes

## User Input / Output

### Basic Input/Output Operations

C++ uses streams for input and output operations. The most common streams are `cin` for input and `cout` for output.

```cpp
#include <iostream>
using namespace std;

int main() {
    string name;
    int age;
    
    // Output
    cout << "Enter your name: ";
    
    // Input
    cin >> name;
    
    cout << "Enter your age: ";
    cin >> age;
    
    // Output with variables
    cout << "Hello " << name << ", you are " << age << " years old!" << endl;
    
    return 0;
}
```

### Important Input/Output Concepts

- `cout` - Standard output stream
- `cin` - Standard input stream
- `endl` - End line manipulator (flushes buffer)
- `\n` - Newline character (faster than endl)
- `getline()` - For reading entire lines including spaces

#### Performance Note: `\n` vs `endl`

**Use `\n` for better performance in most cases:**

```cpp
// Faster - just adds newline
cout << "Hello World\n";

// Slower - adds newline AND flushes buffer
cout << "Hello World" << endl;
```

**Why `\n` is faster:**

- `\n` is a simple escape sequence that only inserts a newline character
- It's a low-level operation that directly moves the cursor to the next line
- `endl` does two operations: adds newline + flushes the output buffer
- Buffer flushing is costly, especially when printing large amounts of text
- Only use `endl` when you specifically need to flush the buffer (like before program termination or when you need immediate output)

```cpp
string fullName;
getline(cin, fullName);  // Reads entire line including spaces
```

## Data Types

### Primitive Data Types

C++ provides several built-in data types with specific size ranges:

#### Integer Types

- `int` - Typically 4 bytes (-2,147,483,648 to 2,147,483,647)
- `short` - Typically 2 bytes (-32,768 to 32,767)
- `long` - Typically 8 bytes (larger range)
- `long long` - 64-bit integer
- `unsigned` variants - Only positive values, double the positive range

#### Floating Point Types

- `float` - 4 bytes, ~7 decimal digits precision
- `double` - 8 bytes, ~15 decimal digits precision
- `long double` - Extended precision

#### Character and Boolean Types

- `char` - 1 byte, stores single character
- `bool` - Stores true/false values
- `string` - Not primitive, but commonly used for text

### Examples

```cpp
int studentCount = 25;
double temperature = 98.6;
char grade = 'A';
bool isPassing = true;
string courseName = "Computer Science";

// Type modifiers
unsigned int positiveOnly = 100;
const double PI = 3.14159;  // Constant value
```

## If Else Statements

### Basic Conditional Structure

If-else statements control program flow based on conditions.

```cpp
if (condition) {
    // Execute if condition is true
} else if (anotherCondition) {
    // Execute if first is false and this is true
} else {
    // Execute if all conditions are false
}
```

### Practical Examples

```cpp
int score;
cout << "Enter your test score: ";
cin >> score;

if (score >= 90) {
    cout << "Grade: A" << endl;
} else if (score >= 80) {
    cout << "Grade: B" << endl;
} else if (score >= 70) {
    cout << "Grade: C" << endl;
} else if (score >= 60) {
    cout << "Grade: D" << endl;
} else {
    cout << "Grade: F" << endl;
}
```

### Logical Operators

- `&&` - AND operator
- `||` - OR operator  
- `!` - NOT operator

```cpp
if (age >= 18 && hasLicense) {
    cout << "Can drive legally" << endl;
}

if (day == "Saturday" || day == "Sunday") {
    cout << "It's weekend!" << endl;
}
```

## Switch Statement

### Basic Switch Structure

Switch statements provide an efficient way to handle multiple discrete values.

```cpp
switch (variable) {
    case value1:
        // Code for value1
        break;
    case value2:
        // Code for value2
        break;
    default:
        // Default case
        break;
}
```

### Practical Example

```cpp
char operation;
double num1, num2;

cout << "Enter operation (+, -, *, /): ";
cin >> operation;

cout << "Enter two numbers: ";
cin >> num1 >> num2;

switch (operation) {
    case '+':
        cout << "Result: " << num1 + num2 << endl;
        break;
    case '-':
        cout << "Result: " << num1 - num2 << endl;
        break;
    case '*':
        cout << "Result: " << num1 * num2 << endl;
        break;
    case '/':
        if (num2 != 0) {
            cout << "Result: " << num1 / num2 << endl;
        } else {
            cout << "Error: Division by zero!" << endl;
        }
        break;
    default:
        cout << "Invalid operation!" << endl;
        break;
}
```

### Important Switch Notes

- `break` is crucial - without it, execution continues to next case
- Only works with integral types (int, char, enum)
- Each case must be a constant expression
- `default` case is optional but recommended

## What are Arrays, Strings?

### Arrays

Arrays are collections of elements of the same data type stored in contiguous memory locations.

#### Array Declaration and Initialization

```cpp
// Declaration
int numbers[5];  // Array of 5 integers

// Declaration with initialization
int scores[5] = {85, 92, 78, 96, 88};

// Size inferred from initialization
int values[] = {1, 2, 3, 4, 5};  // Size is 5

// Partial initialization
int data[10] = {1, 2, 3};  // Rest are initialized to 0
```

#### Array Access and Manipulation

```cpp
int grades[5] = {85, 92, 78, 96, 88};

// Accessing elements (0-indexed)
cout << "First grade: " << grades[0] << endl;  // 85
cout << "Last grade: " << grades[4] << endl;   // 88

// Modifying elements
grades[2] = 95;  // Change third element

// Finding array size
int size = sizeof(grades) / sizeof(grades[0]);
```

### Strings

Strings in C++ can be handled in two ways: C-style strings and C++ string class.

#### C++ String Class (Recommended)

```cpp
#include <string>

string firstName = "John";
string lastName = "Doe";

// String concatenation
string fullName = firstName + " " + lastName;

// String methods
cout << "Length: " << fullName.length() << endl;
cout << "Substring: " << fullName.substr(0, 4) << endl;  // "John"

// String comparison
if (firstName == "John") {
    cout << "Name matches!" << endl;
}
```

#### Common String Operations

```cpp
string text = "Hello World";

// Access individual characters
cout << text[0] << endl;  // 'H'

// Modify characters
text[0] = 'h';  // "hello World"

// String input with spaces
string sentence;
getline(cin, sentence);

// Find substring
size_t pos = text.find("World");
if (pos != string::npos) {
    cout << "Found at position: " << pos << endl;
}
```

## For Loops

### Basic For Loop Structure

For loops are ideal when you know the number of iterations in advance.

```cpp
for (initialization; condition; increment/decrement) {
    // Loop body
}
```

### Common For Loop Patterns

```cpp
// Basic counting loop
for (int i = 0; i < 10; i++) {
    cout << i << " ";
}

// Array traversal
int numbers[5] = {1, 2, 3, 4, 5};
for (int i = 0; i < 5; i++) {
    cout << numbers[i] << " ";
}

// Countdown loop
for (int i = 10; i >= 1; i--) {
    cout << i << " ";
}

// Step by different amounts
for (int i = 0; i <= 100; i += 10) {
    cout << i << " ";  // 0 10 20 30 ... 100
}
```

### Range-Based For Loop (C++11)

```cpp
int array[] = {1, 2, 3, 4, 5};

// Range-based for loop (cleaner syntax)
for (int element : array) {
    cout << element << " ";
}

// With strings
string text = "Hello";
for (char c : text) {
    cout << c << "-";
}
```

### Nested For Loops

```cpp
// Multiplication table
for (int i = 1; i <= 10; i++) {
    for (int j = 1; j <= 10; j++) {
        cout << i * j << "\t";
    }
    cout << endl;
}

// 2D array processing
int matrix[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}};
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        cout << matrix[i][j] << " ";
    }
    cout << endl;
}
```

## While Loops

### Basic While Loop

While loops continue executing as long as a condition remains true.

```cpp
while (condition) {
    // Loop body
    // Don't forget to modify the condition variable!
}
```

### Practical While Loop Examples

```cpp
// Input validation
int number;
cout << "Enter a positive number: ";
cin >> number;

while (number <= 0) {
    cout << "Invalid! Enter a positive number: ";
    cin >> number;
}

// Menu system
int choice = 0;
while (choice != 4) {
    cout << "\n1. Add\n2. Subtract\n3. Multiply\n4. Exit\n";
    cout << "Choose an option: ";
    cin >> choice;
    
    switch (choice) {
        case 1:
            cout << "Addition selected" << endl;
            break;
        case 2:
            cout << "Subtraction selected" << endl;
            break;
        case 3:
            cout << "Multiplication selected" << endl;
            break;
        case 4:
            cout << "Goodbye!" << endl;
            break;
        default:
            cout << "Invalid choice!" << endl;
    }
}
```

### Do-While Loop

Executes the loop body at least once before checking the condition.

```cpp
int guess;
int secret = 7;

do {
    cout << "Guess the number (1-10): ";
    cin >> guess;
    
    if (guess != secret) {
        cout << "Wrong! Try again." << endl;
    }
} while (guess != secret);

cout << "Correct! You guessed it!" << endl;
```

### Loop Control Statements

```cpp
// break - exits the loop immediately
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break;  // Loop ends when i equals 5
    }
    cout << i << " ";
}

// continue - skips rest of current iteration
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) {
        continue;  // Skip even numbers
    }
    cout << i << " ";  // Only prints odd numbers
}
```

## Functions (Pass by Reference and Value)

### Basic Function Structure

Functions help organize code into reusable blocks and improve readability.

```cpp
return_type function_name(parameter_list) {
    // Function body
    return value;  // if return_type is not void
}
```

### Function Examples

```cpp
// Function with no parameters
void greet() {
    cout << "Hello, World!" << endl;
}

// Function with parameters and return value
int add(int a, int b) {
    return a + b;
}

// Function with multiple parameters
double calculateArea(double length, double width) {
    return length * width;
}

// Using functions
int main() {
    greet();
    
    int sum = add(5, 3);
    cout << "Sum: " << sum << endl;
    
    double area = calculateArea(4.5, 3.2);
    cout << "Area: " << area << endl;
    
    return 0;
}
```

### Pass by Value vs Pass by Reference

#### Pass by Value (Default)

When you pass by value, a copy of the variable is made. Changes inside the function don't affect the original variable.

```cpp
void modifyValue(int x) {
    x = 100;  // Only modifies the copy
    cout << "Inside function: " << x << endl;  // 100
}

int main() {
    int number = 50;
    modifyValue(number);
    cout << "Outside function: " << number << endl;  // Still 50
    return 0;
}
```

#### Pass by Reference

When you pass by reference (using `&`), you're working with the original variable directly.

```cpp
void modifyReference(int& x) {
    x = 100;  // Modifies the original variable
    cout << "Inside function: " << x << endl;  // 100
}

int main() {
    int number = 50;
    modifyReference(number);
    cout << "Outside function: " << number << endl;  // Now 100
    return 0;
}
```

### Practical Function Examples

```cpp
// Swap function using references
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// Function to find maximum in array
int findMax(int arr[], int size) {
    int max = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

// Function to validate input
bool isValidAge(int age) {
    return (age >= 0 && age <= 150);
}

// Function overloading (same name, different parameters)
int multiply(int a, int b) {
    return a * b;
}

double multiply(double a, double b) {
    return a * b;
}
```

### Function Best Practices

- Use descriptive function names
- Keep functions focused on a single task
- Use pass by reference for large objects to avoid copying
- Use const references when you don't need to modify the parameter
- Always validate input parameters when necessary

```cpp
// Good practice: const reference for large objects you won't modify
void printString(const string& text) {
    cout << text << endl;
}
```

## Time Complexity [Learn Basics, and then analyse in next Steps]

### Introduction to Time Complexity

Time complexity measures how the runtime of an algorithm grows with the size of the input. It's expressed using Big O notation.

### Common Time Complexities (Best to Worst)

#### O(1) - Constant Time

The algorithm takes the same amount of time regardless of input size.

```cpp
// Array access is O(1)
int getFirstElement(int arr[]) {
    return arr[0];  // Always takes same time
}

// Variable assignment is O(1)
int x = 5;
```

#### O(log n) - Logarithmic Time

Time increases logarithmically with input size. Common in divide-and-conquer algorithms.

```cpp
// Binary search is O(log n)
int binarySearch(int arr[], int size, int target) {
    int left = 0, right = size - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

#### O(n) - Linear Time

Time increases linearly with input size.

```cpp
// Linear search is O(n)
int linearSearch(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}

// Printing all elements is O(n)
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
}
```

#### O(n²) - Quadratic Time

Time increases quadratically with input size. Common with nested loops.

```cpp
// Bubble sort is O(n²)
void bubbleSort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {        // O(n)
        for (int j = 0; j < size - i - 1; j++) { // O(n)
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// Matrix multiplication is O(n³) for n×n matrices
```

### Analyzing Your Code

When analyzing loops and functions:

1. **Single loop through n elements** = O(n)
2. **Nested loops** = Multiply complexities (usually O(n²))
3. **Divide and conquer** = Often O(log n) or O(n log n)
4. **Sequential operations** = Add complexities (take the highest)

### Examples for Practice

```cpp
// What's the time complexity?

// Example 1: O(n)
void example1(int n) {
    for (int i = 0; i < n; i++) {
        cout << i << " ";
    }
}

// Example 2: O(n²)
void example2(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << i << "," << j << " ";
        }
    }
}

// Example 3: O(n) - sequential operations
void example3(int arr[], int n) {
    // First loop: O(n)
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    
    // Second loop: O(n)
    for (int i = 0; i < n; i++) {
        arr[i] = arr[i] * 2;
    }
    // Total: O(n) + O(n) = O(n)
}
```

### Why Time Complexity Matters

Understanding time complexity helps you:

- Choose the right algorithm for your problem
- Predict how your program will perform with larger inputs
- Optimize bottlenecks in your code
- Make informed decisions during technical interviews
